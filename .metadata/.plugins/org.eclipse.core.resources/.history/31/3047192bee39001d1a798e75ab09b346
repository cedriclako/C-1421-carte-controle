/******************************************************************************
  * File Name          : StepperManager.c
  * Description        : Code for Controlling motor position
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2019 SBI inc.
  * All rights reserved.</center></h2>
  *

  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/

#include <MotorManager.h>
#include "main.h"
#include "cmsis_os.h"
#include "task.h"
#include "algo.h"
#include "DebugPort.h"
#include <stdio.h>

static MotorControl_t stMotor[NumberOfMotors];

void vToggleOneStep(motor_t Motor);
void vDisableStepper(motor_t Motor);
void vEnableStepper(motor_t Motor);
bool bStepperZero(motor_t MotorId);
bool vLimitSwitchActive(motor_t MotorId);
void vSetStepperMotorDirection(motor_t Motor, motor_direction_t Direction);
void vStepperPositioning(int RequestedPosition,int *CurrentPosition, motor_t MotorId);
void vStepperMaxTorque(motor_t Motor,bool bApplyMaxTorque);

//remapping of the pin for the current board
#define Primary_Step_SetHigh() HAL_GPIO_WritePin(Step1_STEP_GPIO_Port,Step1_STEP_Pin,GPIO_PIN_SET);
#define Boost_Step_SetHigh() HAL_GPIO_WritePin(Step2_STEP_GPIO_Port,Step2_STEP_Pin,GPIO_PIN_SET);
#define Primary_Step_SetLow() HAL_GPIO_WritePin(Step1_STEP_GPIO_Port,Step1_STEP_Pin,GPIO_PIN_RESET);
#define Boost_Step_SetLow() HAL_GPIO_WritePin(Step2_STEP_GPIO_Port,Step2_STEP_Pin,GPIO_PIN_RESET);
#define Primary_DISABLE() HAL_GPIO_WritePin(Step1_ENABLE_GPIO_Port,Step1_ENABLE_Pin,GPIO_PIN_SET);
#define Boost_DISABLE() HAL_GPIO_WritePin(Step2_ENABLE_GPIO_Port,Step2_ENABLE_Pin,GPIO_PIN_SET);
#define Primary_ENABLE() HAL_GPIO_WritePin(Step1_ENABLE_GPIO_Port,Step1_ENABLE_Pin,GPIO_PIN_RESET);
#define Boost_ENABLE() HAL_GPIO_WritePin(Step2_ENABLE_GPIO_Port,Step2_ENABLE_Pin,GPIO_PIN_RESET);
#define Primary_RESET() HAL_GPIO_WritePin(Step1_RESET_GPIO_Port,Step1_RESET_Pin,GPIO_PIN_RESET);
#define Boost_RESET() HAL_GPIO_WritePin(Step2_RESET_GPIO_Port,Step2_RESET_Pin,GPIO_PIN_RESET);
#define Primary_nRESET() HAL_GPIO_WritePin(Step1_RESET_GPIO_Port,Step1_RESET_Pin,GPIO_PIN_SET);
#define Boost_nRESET() HAL_GPIO_WritePin(Step2_RESET_GPIO_Port,Step2_RESET_Pin,GPIO_PIN_SET);
#define Primary_TorqueMax() HAL_GPIO_WritePin(Step1_LowCurrent_GPIO_Port,Step1_LowCurrent_Pin,GPIO_PIN_RESET);
#define Boost_TorqueMax() HAL_GPIO_WritePin(Step2_LowCurrent_GPIO_Port,step2_LowCurrent_Pin,GPIO_PIN_RESET);
#define Primary_TorqueMin() HAL_GPIO_WritePin(Step1_LowCurrent_GPIO_Port,Step1_LowCurrent_Pin,GPIO_PIN_SET);
#define Boost_TorqueMin() HAL_GPIO_WritePin(step2_LowCurrent_GPIO_Port,step2_LowCurrent_Pin,GPIO_PIN_SET);
#define Primary_DIR_SetHigh() HAL_GPIO_WritePin(Step1_DIR_GPIO_Port,Step1_DIR_Pin,GPIO_PIN_SET);
#define Boost_DIR_SetHigh() HAL_GPIO_WritePin(Step2_DIR_GPIO_Port,Step2_DIR_Pin,GPIO_PIN_SET);
#define Primary_DIR_SetLow() HAL_GPIO_WritePin(Step1_DIR_GPIO_Port,Step1_DIR_Pin,GPIO_PIN_RESET);
#define Boost_DIR_SetLow() HAL_GPIO_WritePin(Step2_DIR_GPIO_Port,Step2_DIR_Pin,GPIO_PIN_RESET);

#define Step1_2_SLEEP() HAL_GPIO_WritePin(uc_Stepper_Sleep_GPIO_Port,uc_Stepper_Sleep_Pin,GPIO_PIN_SET);
#define Step1_2_WAKE() HAL_GPIO_WritePin(uc_Stepper_Sleep_GPIO_Port,uc_Stepper_Sleep_Pin,GPIO_PIN_RESET);

//#define limitSwitchBoostActive() (GPIO_PIN_RESET == HAL_GPIO_ReadPin(LimitSwith1_GPIO_Port,LimitSwith1_Pin))
//#define limitSwitchPrimaryActive() (GPIO_PIN_RESET == HAL_GPIO_ReadPin(LimitSwitch2_GPIO_Port,LimitSwitch2_Pin))

//KIP KOP Temperature for fan operation.
const FanSpeedKipKopParam_t FanSpeedParameters =
{
	.KipSpeed1 = 1300,
	.KopSpeed1 = 1050,
	.KipSpeed2 = 1400,
	.KopSpeed2 = 1250,
	.KipSpeed3 = 1500,
	.KopSpeed3 = 1450,
	.KipSpeed4 = 1600,
	.KopSpeed4 = 1550,
	.NoDemandKipSpeed1 = 1900,
	.NoDemandKopSpeed1 = 1650,
	.NoDemandKopSpeed2 = 1950,
	.NoDemandKipSpeed2 = 1850,
	.NoDemandKipSpeed3 = 2000,
	.NoDemandKopSpeed3 = 1900,
	.NoDemandKipSpeed4 = 2100,
	.NoDemandKopSpeed4 = 1950
};


//private variables
static Mot_FanSpeed plenumSpeed = MOT_PLENUM_STOP;

int stepperPosition[NumberOfMotors];
int BoostPosition = 0;
int PrimarySecondaryPosition = 0;

bool Mot_InPosition( AirInput * self,motor_t Motorid)
{
	return self->aperture == stepperPosition[Motorid];
}

/* USER CODE BEGIN Header_Steppermanager */
/**
* @brief Function implementing the StepperManagerT thread.
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_Steppermanager */
void Steppermanager(void const * argument)
{
  /* USER CODE BEGIN Steppermanager */
  /* Infinite loop */
	//sleep is active low but we inverse the logic with transistor
	//static int BoostPosition = 0;
	//static int PrimarySecondaryPosition = 0;

	HAL_GPIO_WritePin(uc_Stepper_Sleep_GPIO_Port,uc_Stepper_Sleep_Pin,RESET);
	Algo_init();

  for(;;)
  {
//#ifdef TEST_MOTEUR
//	vStepperPositioning(tman_getMoteur1Req(),&BoostPosition,BoostStepper);
//	vStepperPositioning(tman_getMoteur2Req(),&PrimarySecondaryPosition,PrimaryStepper);
//#else
	osDelay(50);
	Algo_task(osKernelSysTick());
	if(Algo_getState() != PRODUCTION_TEST)
	{
		vStepperPositioning(Algo_getGrill(),&stepperPosition[BoostStepper],BoostStepper);
		vStepperPositioning(Algo_getPrimary(),&stepperPosition[PrimaryStepper],PrimaryStepper);
	}
//#endif
  }
  /* USER CODE END Steppermanager */
}

#if GRILL_CIRC
#define primaryStepperMin 6
#else
#define primaryStepperMin 13
#endif

void vStepperPositioning(int RequestedPosition,int *CurrentPosition, motor_t MotorId)
{
    //MotorControl_t* pstMotorControl;
    //pstMotorControl = &stMotor[MotorId];
    int StepToPerform = 0;

    bool StepperToZero = false;

    StepperToZero = vLimitSwitchActive(MotorId);

    if(StepperToZero)
    {
    	if(MotorId == PrimaryStepper)
    	{
    		*CurrentPosition = primaryStepperMin;
    	}
    	else
    	{
    		*CurrentPosition = 0;
    	}

    }
    StepToPerform = *CurrentPosition - RequestedPosition;
    if(MotorId == BoostStepper)
    {
		if (*CurrentPosition == 0 && !StepperToZero)
		{
			StepToPerform = 1;
		}
    }
    else
    {
		if (*CurrentPosition == primaryStepperMin && !StepperToZero)
		{
			StepToPerform = 1;
		}
    }

    while (StepToPerform != 0)
    {
    	vEnableStepper(MotorId);
    	vStepperMaxTorque(MotorId,true);
    	//osDelay(20);
    	if(StepToPerform > 0)
		{
			vSetStepperMotorDirection(MotorId, Closing);
			*CurrentPosition = *CurrentPosition -1;
			if((*CurrentPosition < 0) && (MotorId == BoostStepper))
			{
				*CurrentPosition = 0;
				vDisableStepper(BoostStepper);
			}
			else if ((*CurrentPosition < primaryStepperMin) && (MotorId == PrimaryStepper))
			{
				*CurrentPosition = primaryStepperMin;
				vDisableStepper(PrimaryStepper);
			}
 			vToggleOneStep(MotorId);
			StepToPerform--;
		}
		else if(StepToPerform < 0)
		{
			vEnableStepper(MotorId);
			osDelay(50);
			vSetStepperMotorDirection(MotorId, Opening);
			*CurrentPosition = *CurrentPosition + 1;
			vToggleOneStep(MotorId);
			StepToPerform++;
		}
		//Calculate or new position
	}
    //vStepperMaxTorque(MotorId,true); TODO : re-enable max torque
    //osDelay(100);
	//vDisableStepper(MotorId);

}

void vToggleOneStep(motor_t Motor)
{
    switch(Motor)
    {
        case PrimaryStepper:
            Primary_Step_SetLow();
            osDelay(10);
            Primary_Step_SetHigh();
            osDelay(10);
            break;
        case BoostStepper:
            Boost_Step_SetLow();
            osDelay(10);
            Boost_Step_SetHigh();
            osDelay(10);
            break;
        default:
            break;
    }
}
bool vLimitSwitchActive(motor_t MotorId)
{
	bool active=false;
    switch(MotorId)
    {
#if defined REVC
    	case PrimaryStepper:
#else
        case BoostStepper:
#endif
        	active = (GPIO_PIN_RESET == HAL_GPIO_ReadPin(LimitSwith1_GPIO_Port,LimitSwith1_Pin));
            break;
#if defined REVC
        case BoostStepper:
#else
        case PrimaryStepper:
#endif
        	active = (GPIO_PIN_RESET == HAL_GPIO_ReadPin(LimitSwitch2_GPIO_Port,LimitSwitch2_Pin));
        default:
            break;
    }
    return active;
}

void vEnableStepper(motor_t Motor)
{
    Step1_2_WAKE();
	switch(Motor)
    {
        case PrimaryStepper:
            Primary_ENABLE();
            Primary_nRESET();
            break;
        case BoostStepper:
            Boost_ENABLE();
            Boost_nRESET();

            break;
        default:
            break;
    }
}
void vStepperMaxTorque(motor_t Motor,bool bApplyMaxTorque)
{
	switch(Motor)
    {
        case PrimaryStepper:
        	if(bApplyMaxTorque)
        	{
        		Primary_TorqueMax();
        	}
        	else
        	{
        		Primary_TorqueMin();
        	}
            break;
        case BoostStepper:
        	if(bApplyMaxTorque)
        	{
        		Boost_TorqueMax();
        	}
        	else
			{
        		Boost_TorqueMin();
        	}
            break;
        default:
            break;
    }
}

void vDisableStepper(motor_t Motor)
{
	//Step1_2_SLEEP();
    switch(Motor)
    {
        case PrimaryStepper:
            Primary_DISABLE();
            break;
        case BoostStepper:
            Boost_DISABLE();
            break;
        default:
            break;
    }
}

void vSetStepperMotorDirection(motor_t Motor, motor_direction_t Direction)
{
    if(Motor == BoostStepper)
    {
        if(Direction == Opening)
        {
        	Boost_DIR_SetHigh();
        }
        else
        {
        	Boost_DIR_SetLow();
        }
    }
    else if(Motor == PrimaryStepper)
    {
        if(Direction == Opening)
        {
        	Primary_DIR_SetHigh();
        }
        else
        {
        	Primary_DIR_SetLow();
        }
    }
    else
    {
        while(1);
        //wrong motor argument
    }
}

void mot_SetStepMotor(motor_t MotorId, uint8_t ui8Opening)
{
    stMotor[MotorId].i8PositionRequested = ui8Opening;
}

MotorControl_t* pstGetMotor(motor_t Index)
{
    return &stMotor[Index];
}

void vSetSpeed(Mot_FanSpeed RequestedSpeed)
{
	  switch (RequestedSpeed)
	  {
		  case 1://speed1
			  HAL_GPIO_WritePin(SPEED2_COIL_GPIO_Port,SPEED2_COIL_Pin,RESET);
			  HAL_GPIO_WritePin(SPEED3_COIL_GPIO_Port,SPEED3_COIL_Pin,RESET);
			  osDelay(200);//break before make
			  HAL_GPIO_WritePin(SPEED1_COIL_GPIO_Port,SPEED1_COIL_Pin,SET);
			  break;
		  case 2://speed2
			  HAL_GPIO_WritePin(SPEED3_COIL_GPIO_Port,SPEED3_COIL_Pin,RESET);
			  HAL_GPIO_WritePin(SPEED1_COIL_GPIO_Port,SPEED1_COIL_Pin,RESET);
			  osDelay(200);//break before make
			  HAL_GPIO_WritePin(SPEED2_COIL_GPIO_Port,SPEED2_COIL_Pin,SET);
			  break;
		  case 3://speed3
			  HAL_GPIO_WritePin(SPEED1_COIL_GPIO_Port,SPEED1_COIL_Pin,RESET);
			  HAL_GPIO_WritePin(SPEED2_COIL_GPIO_Port,SPEED2_COIL_Pin,RESET);
			  osDelay(200);//break before make
			  HAL_GPIO_WritePin(SPEED3_COIL_GPIO_Port,SPEED3_COIL_Pin,SET);
			  break;
		  case 4: //speed4 controlled by hardware
		  default: //stop
			  HAL_GPIO_WritePin(SPEED1_COIL_GPIO_Port,SPEED1_COIL_Pin,RESET);
			  HAL_GPIO_WritePin(SPEED2_COIL_GPIO_Port,SPEED2_COIL_Pin,RESET);
			  HAL_GPIO_WritePin(SPEED3_COIL_GPIO_Port,SPEED3_COIL_Pin,RESET);
			  break;
	  }
}

Mot_FanSpeed Mot_getFanSpeed() {
  return plenumSpeed;
}

void managePlenumSpeed(int plenumTemp, bool thermostatRequest,uint32_t Time_ms) {

	static Mot_FanSpeed plenumPreviousSpeed = MOT_PLENUM_STOP;
	static uint32_t TimeSinceReloadRequest = 0;
	uint32_t TimeOfReloadRequest;


    int tempstate = Algo_getState();
    TimeOfReloadRequest = Algo_getTimeOfReloadRequest();
    TimeSinceReloadRequest = Time_ms - TimeOfReloadRequest;

	if(tempstate == RELOAD_IGNITION && fanPauseRequired)
	{
		if(TimeSinceReloadRequest > MINUTES(2))
		{
			fanPauseRequired = false;
		}
		else
		{
			plenumSpeed = MOT_PLENUM_STOP;
		}
	}
	else
	{
	  if(thermostatRequest) {
		  if(plenumTemp <= FanSpeedParameters.KopSpeed1 || (plenumTemp < FanSpeedParameters.KipSpeed1 && plenumPreviousSpeed == MOT_PLENUM_STOP))
		  {
			plenumSpeed = MOT_PLENUM_STOP;
		  }
		  else
		  {
			plenumSpeed = MOT_PLENUM_LOW;
		  }
	  }
	  else {
		plenumSpeed = (plenumTemp >= FanSpeedParameters.NoDemandKopSpeed1 && plenumPreviousSpeed == MOT_PLENUM_LOW) || plenumTemp >= FanSpeedParameters.NoDemandKipSpeed1 ? MOT_PLENUM_LOW : MOT_PLENUM_STOP;
	  }
	}

//	  if (tempstate == RELOAD_IGNITION && (plenumTemp <= (FanSpeedParameters.NoDemandKipSpeed1-100)))
//	  {
//		  //overwrite when in reload to avoid smoke if door is open unless temperature above 165F.
//		  plenumSpeed = MOT_PLENUM_STOP;
//	  }
	  if(tempstate == PRODUCTION_TEST)
	  {
		  //do nothing handle in test prod
	  }
	  else
	  {
		  vSetSpeed(plenumSpeed);
	  }
  plenumPreviousSpeed = plenumSpeed;
}

void StepperMotorProdTest(motor_t MotorId)
{
	// on ouvre jusqu'à ce que la limite switch soit inactive,
	// on ferme jusqu'à ce qu'elle soit active
	//on va au max et on ferme sur la switch
	//on ouvre à 25% et on désactive les moteurs.

	vSetStepperMotorDirection(MotorId, Opening);
	vEnableStepper(MotorId);
	while(vLimitSwitchActive(MotorId))
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	vSetStepperMotorDirection(MotorId, Closing);
	while(!vLimitSwitchActive(MotorId))
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	vSetStepperMotorDirection(MotorId, Opening);
	int stepToFull;
	stepToFull = (MotorId == PrimaryStepper)?STEP_RANGE_PRIMARY:STEP_RANGE_GRILL;
	int i;
	for (i=0;i<=stepToFull;i++)
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	vSetStepperMotorDirection(MotorId, Closing);
	for (i=0;i<=stepToFull;i++)
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	//repeat for proper 0
	vSetStepperMotorDirection(MotorId, Opening);
	while(vLimitSwitchActive(MotorId))
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	vSetStepperMotorDirection(MotorId, Closing);
	while(!vLimitSwitchActive(MotorId))
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	vSetStepperMotorDirection(MotorId, Opening);
	for (i=0;i<=stepToFull/3;i++)
	{
		vToggleOneStep(MotorId);
		osDelay(5);
	}
	vDisableStepper(MotorId);
}
void AllMotorToZero()
{
	int i=0;

	for(i=0;i<NumberOfMotors;i++)
	{
		vEnableStepper(i);
		vSetStepperMotorDirection(i, Opening);
		while(vLimitSwitchActive(i))
		{
			vToggleOneStep(i);
			osDelay(5);
		}
		vSetStepperMotorDirection(i, Closing);
		while(!vLimitSwitchActive(i))
		{
			vToggleOneStep(i);
			osDelay(5);
		}
	}
}


